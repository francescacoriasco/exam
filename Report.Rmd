
---
title: "ExamPipeline — Report (Steps 3–14)"
output:
  html_document:
    toc: true
    toc_depth: 3
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo    = TRUE,
  warning = FALSE,
  message = FALSE,
  error   = TRUE
)

# -----------------------------
# Paths
# -----------------------------
pkg_root <- "/workspace/myproj"

data_dir <- "/workspace/data"
refs_dir <- "/workspace/refs"
res_dir  <- "/workspace/results"

step5_dir  <- file.path(res_dir, "step5_mtx_out_scRNA_only")
step7_dir  <- file.path(res_dir, "step7_mtx_rp_only")
step8_dir  <- file.path(res_dir, "step8_plots")
step9_dir  <- file.path(res_dir, "step9_ARI_sweep_RP_only")
step11_dir <- file.path(res_dir, "step11_atac_objects_rp_only")
step13_dir <- file.path(res_dir, "step13_plots")
step14_dir <- file.path(res_dir, "step14_param_sweep_atac")

dir.create(refs_dir,   showWarnings = FALSE, recursive = TRUE)
dir.create(res_dir,    showWarnings = FALSE, recursive = TRUE)
dir.create(step5_dir,  showWarnings = FALSE, recursive = TRUE)
dir.create(step7_dir,  showWarnings = FALSE, recursive = TRUE)
dir.create(step8_dir,  showWarnings = FALSE, recursive = TRUE)
dir.create(step9_dir,  showWarnings = FALSE, recursive = TRUE)
dir.create(step11_dir, showWarnings = FALSE, recursive = TRUE)
dir.create(step13_dir, showWarnings = FALSE, recursive = TRUE)
dir.create(step14_dir, showWarnings = FALSE, recursive = TRUE)

# -----------------------------
# Reference files
# -----------------------------
rp_ids_rds  <- file.path(refs_dir, "rp_gene_ids_release115.rds")
gtf_rp_gz   <- file.path(refs_dir, "Homo_sapiens.GRCh38.115.RP_only.gtf.gz")
rp_loci_rds <- file.path(refs_dir, "rp_gene_loci_GRanges_release115.rds")
step12_rds  <- file.path(res_dir, "step12_ATAC_RP_combined.rds")

# -----------------------------
# Install/load local package
# -----------------------------
if (!requireNamespace("examPipeline", quietly = TRUE)) {
  install.packages(pkg_root, repos = NULL, type = "source")
}
library(examPipeline)

# -----------------------------
# Helpers
# -----------------------------
kable_paths <- function(x, col = "path") {
  if (is.null(x) || length(x) == 0) return(invisible(NULL))
  df <- data.frame(as.character(x), stringsAsFactors = FALSE)
  names(df) <- col
  knitr::kable(df)
}
ls_dir <- function(d) {
  if (!dir.exists(d)) return(character())
  sort(list.files(d, full.names = TRUE))
}
```
# Introduction

This report describes a reproducible analysis pipeline for 10x Genomics single-cell data from **GSE307240**, integrating **scRNA-seq** and **scATAC-seq** across multiple **patient-derived xenograft (PDX)** samples. The workflow is implemented as an R package (`examPipeline`) and executed as an ordered set of steps (Steps 3–14), producing standardized intermediate files and final results suitable for downstream interpretation.

A central focus of the analysis is the **ribosomal-protein (RP)** gene program. The pipeline (i) extracts RP gene identifiers from an Ensembl GTF annotation, (ii) restricts the scRNA-seq expression matrix to RP features, and (iii) evaluates whether RP-only signal is sufficient to separate PDX samples in low-dimensional embeddings and clustering.

In parallel, the scATAC-seq component quantifies chromatin accessibility over genomic loci associated with RP genes. By building RP loci as `GRanges` objects and restricting fragment counting to these regions, the ATAC analysis is aligned with the RP-focused RNA analysis. Final outputs include UMAP-based visualizations and clustering for both modalities, as well as parameter sweeps evaluated using the **Adjusted Rand Index (ARI)** to compare clustering configurations.

# Data description

**GSE307240** provides 10x Genomics single-cell data generated from multiple PDX samples, with two complementary modalities:

* **scRNA-seq (expression)**: 10x HDF5 (`.h5`) files containing sparse gene × cell count matrices (and potentially multiple feature types). These files quantify transcript abundance per cell.
* **scATAC-seq (chromatin accessibility)**: fragment files (`*_fragments.tsv.gz` or `*.bgz`) containing genomic coordinates of Tn5 integration events linked to cell barcodes. These files quantify accessibility over genomic regions (here restricted to RP loci).

Inputs are stored locally using the following layout:

* `data_dir = /workspace/data`
  Raw input files (scRNA `.h5` and ATAC fragments) for all PDX samples.
* `refs_dir = /workspace/refs`
  Reference/annotation files produced or used by the workflow, including RP gene identifiers, RP-only GTF, and RP loci (`GRanges`).
* `res_dir = /workspace/results`
  Step-specific outputs (exported MTX bundles, plots, ARI sweep summaries, and merged serialized objects).

Because the number of cells differs across runs, the pipeline standardizes the analysis by **reproducibly subsampling 500 cells per scRNA dataset** (fixed random seed and deterministic ordering). The selected cell barcodes are then **propagated to the ATAC workflow**, ensuring that each per-PDX ATAC object is built using the same subset of cells retained from scRNA-seq.

---

# Results

## Step 3 — Load `.h5` and select scRNA-seq count matrices

```{r step3_call, results='hide'}
scrna_h5 <- step3_select_scrna_h5(
  data_dir = data_dir,
  recursive = TRUE,
  verbose = FALSE
)
```

**Step 3 output:** scRNA-seq `.h5` files retained = `r length(scrna_h5)`.

```{r step3_out, echo=FALSE, results='asis'}
kable_paths(scrna_h5, col = "h5_path")
cat("\n\n&nbsp;\n\n")
```

**Motivation / what this step checks (per assignment).**
The raw folder can include files that are not purely scRNA. Step 3 keeps only `.h5` files that contain **Gene Expression/RNA** features, ensuring downstream RNA analysis is applied to the correct modality.

**Result comment.**
The table lists the `.h5` files used for the RNA branch. This should match the expected set of PDX experiments.

---

## Step 4 — Subsample 500 cells from each dataset

```{r step4_call, results='hide'}
objs <- step4_subsample_scrna_to_seurat(
  scrna_files = scrna_h5,
  sample_n = 500,
  seed = 1,
  verbose = FALSE
)
```

**Step 4 output:** Seurat objects created = `r length(objs)`.

```{r step4_out, echo=FALSE, results='asis'}
dims_tbl <- data.frame(
  sample = names(objs),
  genes  = vapply(objs, function(o) as.integer(nrow(o)), integer(1)),
  cells  = vapply(objs, function(o) as.integer(ncol(o)), integer(1)),
  stringsAsFactors = FALSE
)
knitr::kable(dims_tbl)
cat("\n\n&nbsp;\n\n")
```

**Motivation (per assignment).**
Cell numbers can differ across experiments; subsampling to 500 cells per dataset yields comparable representation and reduces runtime/memory.

**Result comment.**
Each dataset should show ~500 cells (or fewer only if the source had fewer). This table documents the exact dimensions used.

---

## Step 5 — Merge subsampled cells and export sparse MTX

```{r step5_call, results='hide'}
s5 <- step5_merge_and_export_mtx(
  objs = objs,
  out_dir = step5_dir,
  prefix = NULL,
  overwrite = TRUE,
  verbose = FALSE
)
```

**Step 5 output:** merged expression matrix = `r s5$dims["genes"]` genes × `r s5$dims["cells"]` cells.

```{r step5_out, echo=FALSE, results='asis'}
out_df <- data.frame(
  name = names(s5$out_files),
  file = unlist(s5$out_files, use.names = FALSE),
  stringsAsFactors = FALSE
)
knitr::kable(out_df)
cat("\n\n&nbsp;\n\n")

kable_paths(unlist(s5$out_files, use.names = FALSE), col = "file")
cat("\n\n&nbsp;\n\n")
```

**Motivation (per assignment).**
Merging creates a single expression dataset (500 cells × experiments), and exporting to MTX makes the intermediate portable and auditable.

**Result comment.**
The merged cell count should be close to 5 × 500 = 2500. The MTX bundle is the input for Step 7.

---

## Step 6 — Download Ensembl GTF (release 115) and retain only RP entries

```{r step6_call, results='hide'}
s6 <- step6_extract_rp_from_gtf(
  refs_dir = refs_dir,
  release = 115,
  verbose = FALSE
)
```

**Step 6 output:** RP gene_ids = `r length(s6$rp_gene_ids)`.

```{r step6_out, echo=FALSE, results='asis'}
knitr::kable(data.frame(
  item = c("Full GTF (release 115)", "RP gene_id list (RDS)", "RP-only GTF"),
  path = c(s6$gtf_gz, s6$rp_ids_rds, s6$gtf_rp_gz),
  stringsAsFactors = FALSE
))
cat("\n\n&nbsp;\n\n")
```

**Motivation (per assignment).**
This step defines the RP feature set from Ensembl release 115 by retaining entries whose `gene_name` begins with “RP”.

**Result comment.**
The three outputs (full GTF, RP id list, RP-only GTF) are saved under `refs_dir` and reused by the RNA and ATAC branches.

---

## Step 7 — Filter combined scRNA matrix to RP-only features

```{r step7_call, results='hide'}
s7 <- step7_filter_mtx_to_rp(
  in_dir = step5_dir,
  rp_ids_rds = rp_ids_rds,
  out_dir = step7_dir,
  verbose = FALSE
)
```

**Step 7 output:** RP-only matrix = `r s7$dims["features"]` features × `r s7$dims["cells"]` cells.
RP features retained: `r s7$kept_features`.

```{r step7_out, echo=FALSE, results='asis'}
kable_paths(ls_dir(step7_dir), col = "file")
cat("\n\n&nbsp;\n\n")
```

**Motivation (per assignment).**
Restricting the expression matrix to RP genes tests whether ribosomal programs alone can separate PDX samples.

**Result comment.**
The RP-only MTX bundle is the input for Seurat clustering in Step 8.

---

## Step 8 — Run Seurat clustering and visualize cells colored by PDX

```{r step8_call, results='hide'}
s8 <- step8_seurat_umap_by_pdx(
  in_dir = step7_dir,
  out_dir = step8_dir,
  save_plots = TRUE,
  verbose = FALSE
)
```

**Step 8 output:** Seurat object = `r nrow(s8$obj)` features × `r ncol(s8$obj)` cells.

```{r step8_out, echo=FALSE, results='asis'}
png8 <- file.path(step8_dir, "umap_by_pdx.png")
if (file.exists(png8)) knitr::include_graphics(png8) else knitr::kable(data.frame(missing_plot = png8))
cat("\n\n&nbsp;\n\n")
```

**Motivation (per assignment).**
Clustering/UMAP on RP-only RNA evaluates whether PDX identity aligns with ribosomal expression patterns.

**Result comment.**
If PDX samples separate, points of the same PDX will tend to occupy coherent regions of the embedding; overlap suggests RP-only signal is not sufficient alone.

---

## Step 9 — Sweep clustering settings and quantify PDX separation (ARI)

```{r step9_call, results='hide'}
s9 <- step9_ari_sweep_rp(
  obj = s8$obj,
  out_dir = step9_dir,
  verbose = FALSE
)
```

**Step 9 output:** best configuration (by ARI) and a preview of the sweep results.

```{r step9_out, echo=FALSE, results='asis'}
knitr::kable(s9$best)
cat("\n\n&nbsp;\n\n")
knitr::kable(utils::head(s9$results, 10))
cat("\n\n&nbsp;\n\n")
kable_paths(s9$out_files, col = "file")
cat("\n\n&nbsp;\n\n")
```

**Motivation (per assignment).**
Sweeping parameters (e.g., resolution/PCs/neighbors) tests robustness of PDX separation under RP-only signal.

**Result comment.**
Higher ARI indicates stronger agreement between clustering and PDX labels for that configuration; the saved tables allow full inspection.

---

## Step 10 — Build a GenomicRanges object of RP loci from RP-only GTF

```{r step10_call, results='hide'}
s10 <- step10_build_rp_loci_granges(
  gtf_rp_gz = gtf_rp_gz,
  out_rds = rp_loci_rds,
  verbose = FALSE
)
```

**Step 10 output:** RP loci (gene-level) = `r length(s10$gr_gene)`.

```{r step10_out, echo=FALSE, results='asis'}
kable_paths(s10$out_rds, col = "rp_loci_rds")
cat("\n\n&nbsp;\n\n")
```

**Motivation (per assignment).**
This creates genomic intervals for RP loci used to restrict ATAC fragments to RP-associated regions.

**Result comment.**
The saved `GRanges` is reused in Step 11 to count only fragments overlapping RP loci.

---

## Step 11 — Create one ATAC object per PDX restricted to RP loci and same 500 cells

```{r step11_call, results='hide'}
s11 <- step11_build_atac_per_pdx_rp(
  data_dir     = data_dir,
  barcodes_tsv = file.path(step5_dir, "barcodes.tsv"),
  rp_loci_rds  = rp_loci_rds,
  out_dir      = step11_dir,
  verbose      = FALSE
)
```

**Step 11 output:** ATAC objects created = `r s11$created`.

```{r step11_out, echo=FALSE, results='asis'}
kable_paths(s11$paths, col = "atac_rds")
cat("\n\n&nbsp;\n\n")
```

**Motivation (per assignment).**
Per-PDX ATAC objects are restricted to fragments overlapping RP loci and the same barcodes retained in the RNA branch.

**Result comment.**
Successful creation indicates: (i) fragments were found and indexed, (ii) RP-locus overlaps were computed, and (iii) barcodes were aligned to the RNA subsample.

---

## Step 12 — Merge the 5 ATAC objects into a combined dataset

```{r step12_call, results='hide'}
s12 <- step12_merge_atac_objects(
  in_dir  = step11_dir,
  out_rds = step12_rds,
  verbose = FALSE
)
```

**Step 12 output:** combined ATAC = `r nrow(s12$atac_combined)` features × `r ncol(s12$atac_combined)` cells.

```{r step12_out, echo=FALSE, results='asis'}
kable_paths(s12$out_rds, col = "atac_combined_rds")
cat("\n\n&nbsp;\n\n")
```

**Motivation (per assignment).**
Merging yields a single ATAC dataset aligned to RP loci, enabling clustering/UMAP across all PDX samples.

**Result comment.**
The merged cell count should be close to 2500 (5 × 500), consistent with the RNA subsampling.

---

## Step 13 — Perform ATAC clustering and plot cells colored by PDX

```{r step13_call, results='hide'}
s13 <- step13_atac_umap_by_pdx(
  atac = step12_rds,
  out_dir = step13_dir,
  save_plots = TRUE,
  verbose = FALSE
)
```

**Step 13 output:** ATAC object = `r nrow(s13$atac)` features × `r ncol(s13$atac)` cells.

```{r step13_out, echo=FALSE, results='asis'}
png13 <- file.path(step13_dir, "umap_by_pdx.png")
if (file.exists(png13)) knitr::include_graphics(png13) else knitr::kable(data.frame(missing_plot = png13))
cat("\n\n&nbsp;\n\n")
```

**Motivation (per assignment).**
ATAC clustering/UMAP tests whether RP-locus accessibility alone separates the PDX samples.

**Result comment.**
Separation by PDX would suggest that RP-locus chromatin state differs systematically across the patient-derived samples.

---

## Step 14 — Sweep ATAC clustering parameters to assess PDX separation (ARI)

```{r step14_call, results='hide'}
s14 <- step14_ari_sweep_atac(
  atac = s13$atac,
  out_dir = step14_dir,
  verbose = FALSE
)
```

**Step 14 output:** best configuration (by ARI) and a preview of the sweep results.

```{r step14_out, echo=FALSE, results='asis'}
knitr::kable(s14$best)
cat("\n\n&nbsp;\n\n")
knitr::kable(utils::head(s14$results, 10))
cat("\n\n&nbsp;\n\n")
kable_paths(s14$out_files, col = "file")
cat("\n\n&nbsp;\n\n")
```

**Motivation (per assignment).**
Parameter sweeps quantify robustness of PDX separation using RP-locus accessibility, summarized by ARI across configurations.

**Result comment.**
As in the RNA branch, ARI summarizes agreement between clustering and known PDX labels across parameter choices.


---

# Discussion

Some technical issues arose during development and execution of the pipeline; they were resolved to ensure that the workflow runs reproducibly end-to-end.

**1. Memory pressure.** A major technical issue encountered during the analysis concerned RAM usage when loading data into Seurat objects. Directly importing full 10x datasets and constructing Seurat objects for multiple PDX samples resulted in memory saturation, particularly during merging steps and downstream dimensionality reduction, leading to session instability and occasional crashes. The problem was mainly attributable to the large size of the raw count matrices, the in-memory duplication of objects during Seurat preprocessing steps such as normalization, scaling, and PCA, and temporary memory spikes generated during object merging. To address this limitation, the workflow was redesigned to reduce memory demand at multiple stages. Instead of loading all available cells, a fixed number of cells per dataset (e.g., 500 per PDX) was selected prior to full object construction, substantially decreasing the overall memory footprint while preserving comparability across samples. In addition, downstream analyses were restricted to ribosomal-protein (RP) genes, which markedly reduced matrix dimensionality and computational burden. Count matrices were maintained in sparse format whenever possible to prevent unnecessary dense matrix expansion. Furthermore, objects were processed independently per PDX and merged only after dimensionality reduction when feasible, thereby minimizing peak RAM consumption. Finally, BLAS and OMP threads were limited within the Docker environment to avoid parallel memory spikes. After implementing these adjustments, Seurat objects could be loaded and processed reliably without exceeding available RAM, ensuring stable execution of the pipeline while maintaining analytical consistency.

**2. JoinLayers availability.** During development, compatibility issues were encountered with the JoinLayers function in Seurat v5. In some environments, JoinLayers was not exported or not available under the expected namespace, leading to execution errors when attempting to combine assay layers. This created instability in workflows relying on explicit layer manipulation. To resolve this issue, hard dependencies on JoinLayers were removed and layer access was implemented using version-robust strategies compatible with the installed Seurat release. By adapting the code to handle assay layers more flexibly, the workflow remained functional across different Seurat versions without requiring strict package version pinning.

**3. ATAC fragment requirements (bgzip + tabix).** Another technical constraint emerged in the ATAC branch concerning fragment file requirements in Signac. Chromatin assays in Signac require fragment files to be bgzip-compressed and accompanied by a valid tabix index. When fragment files were not provided in the correct .bgz format or lacked proper indexing, object construction failed. This was resolved by converting fragment files to bgzip-compressed format and generating the corresponding tabix index prior to building ChromatinAssay objects. Ensuring proper compression and indexing allowed fragments to be queried efficiently and enabled successful construction of ATAC objects.

Overall, addressing these compatibility and file-format requirements improved the robustness and portability of the pipeline across computational environments and package versions.
